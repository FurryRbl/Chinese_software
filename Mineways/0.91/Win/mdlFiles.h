#include "stdafx.h"

const char* file_Mineways[] = {
	"/***************************************************************************************************\n",
	" * Copyright 2020 NVIDIA Corporation. All rights reserved.\n",
	" *\n",
	" * Redistribution and use in source and binary forms, with or without\n",
	" * modification, are permitted provided that the following conditions\n",
	" * are met:\n",
	" *  * Redistributions of source code must retain the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer.\n",
	" *  * Redistributions in binary form must reproduce the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer in the\n",
	" *    documentation and/or other materials provided with the distribution.\n",
	" *  * Neither the name of NVIDIA CORPORATION nor the names of its\n",
	" *    contributors may be used to endorse or promote products derived\n",
	" *    from this software without specific prior written permission.\n",
	" *\n",
	" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n",
	" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n",
	" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n",
	" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n",
	" * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n",
	" * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n",
	" * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n",
	" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n",
	" * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n",
	" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n",
	" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
	" **************************************************************************************************/\n",
	"\n",
	"// A wrapper for Mineways for Omni's surface lite using nearest neighbour texture lookups\n",
	"\n",
	"mdl 1.6;\n",
	"\n",
	"\n",
	"import ::base::*;\n",
	"import ::anno::*;\n",
	"import ::tex::*;\n",
	"import OmniSurfaceLiteNN::*;\n",
	"import OmniImageNN::*;\n",
	"import OmniShared::*;\n",
	"\n",
	"export material Mineways(\n",
	"    uniform texture_2d diffuse_texture = texture_2d()\n",
	"        [[ anno::display_name(\"Diffuse Texture\") ]],\n",
	"\n",
	"    uniform float metallic_constant = 0.0,\n",
	"    uniform texture_2d metallic_texture = texture_2d(),\n",
	"    uniform float metallic_texture_influence = 0.0,\n",
	"\n",
	"    uniform float geometry_normal_strength = 1.0,\n",
	"    uniform texture_2d normalmap_texture = texture_2d(),\n",
	"    \n",
	"    uniform float reflection_roughness_constant = 0.5,\n",
	"    uniform texture_2d reflectionroughness_texture = texture_2d(),\n",
	"    uniform float reflection_roughness_texture_influence = 0.2,\n",
	"\n",
	"    uniform bool enable_emission = false,\n",
	"    uniform texture_2d  emissive_mask_texture = texture_2d(),\n",
	"    uniform float emissive_intensity = 0.0,\n",
	"    uniform color emissive_color = color(0.0),\n",
	"    uniform texture_2d emissive_color_texture = texture_2d(),\n",
	"\n",
	"    uniform bool enable_opacity = false,\n",
	"    uniform texture_2d opacity_texture = texture_2d(),\n",
	"    // uniform ::base::mono_mode opacity_mode = ::base::mono_alpha,\n",
	"\n",
	"    uniform bool thin_walled = false,\n",
	"\n",
	"    uniform bool filtered_textures = false\n",
	"    \n",
	") = OmniSurfaceLiteNN::OmniSurfaceLiteNN(\n",
	"    diffuse_reflection_color_image: diffuse_texture,\n",
	"    \n",
	"    metalness: // only limited support for ..._constant\n",
	"        (metallic_texture_influence == 0.0\n",
	"	 || ! tex::texture_isvalid(metallic_texture))\n",
	"            ? metallic_constant : metallic_texture_influence,\n",
	"    metalness_image: metallic_texture,\n",
	"\n",
	"    geometry_normal_strength: geometry_normal_strength,\n",
	"    geometry_normal_image: normalmap_texture,\n",
	"\n",
	"    specular_reflection_roughness: // only limited support for ..._constant\n",
	"        (reflection_roughness_texture_influence == 0.0\n",
	"        || ! tex::texture_isvalid(reflectionroughness_texture))\n",
	"            ? reflection_roughness_constant\n",
	"            : reflection_roughness_texture_influence,\n",
	"    specular_reflection_roughness_image: reflectionroughness_texture,\n",
	"    emission_weight: ( enable_emission ? 1.0: 0.0), \n",
	"    emission_weight_image: emissive_mask_texture,\n",
	"    emission_intensity: emissive_intensity,\n",
	"    emission_color: emissive_color,\n",
	"    emission_color_image: emissive_color_texture,\n",
	"    \n",
	"    enable_opacity: enable_opacity,\n",
	"    geometry_opacity: 1.0,\n",
	"    geometry_opacity_image: opacity_texture,\n",
	"\n",
	"// Bug: this fails, hard coded for now\n",
	"//    geometry_opacity_image_alpha_mode:\n",
	"//        OmniImageNN::alpha_from_mono_mode( opacity_mode),\n",
	"    geometry_opacity_image_alpha_mode: OmniImageNN::alpha_default,\n",
	"\n",
	"    // reasonable defaults for emitters in particular\n",
	"    diffuse_reflection_weight: 1.0,\n",
	"    specular_reflection_weight: 1.0,\n",
	"    specular_reflection_roughness_image_alpha_mode: OmniImageNN::alpha_red,\n",
	"    metalness_image_alpha_mode: OmniImageNN::alpha_green,\n",
	"    emission_weight_image_alpha_mode: OmniImageNN::alpha_red,\n",
	"    emission_intensity_image_alpha_mode: OmniImageNN::alpha_blue,\n",
	"    emission_mode: OmniShared::emission_nt,\n",
	"    thin_walled: thin_walled,\n",
	"    filtered_textures: filtered_textures\n",
	");\n",
};

const char* file_OmniImageNN[] = {
	"/***************************************************************************************************\n",
	" * Copyright 2020 NVIDIA Corporation. All rights reserved.\n",
	" *\n",
	" * Redistribution and use in source and binary forms, with or without\n",
	" * modification, are permitted provided that the following conditions\n",
	" * are met:\n",
	" *  * Redistributions of source code must retain the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer.\n",
	" *  * Redistributions in binary form must reproduce the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer in the\n",
	" *    documentation and/or other materials provided with the distribution.\n",
	" *  * Neither the name of NVIDIA CORPORATION nor the names of its\n",
	" *    contributors may be used to endorse or promote products derived\n",
	" *    from this software without specific prior written permission.\n",
	" *\n",
	" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n",
	" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n",
	" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n",
	" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n",
	" * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n",
	" * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n",
	" * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n",
	" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n",
	" * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n",
	" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n",
	" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
	" **************************************************************************************************/\n",
	"\n",
	"// Omni's image lookup functionalities\n",
	"\n",
	"mdl 1.6;\n",
	"\n",
	"import ::df::*;\n",
	"import ::base::*;\n",
	"import ::math::*;\n",
	"import ::state::*;\n",
	"import ::tex::*;\n",
	"import ::limits::*;\n",
	"import ::anno::*;\n",
	"\n",
	"export enum wrap_mode \n",
	"[[ \n",
	"    anno::description(\"Wrap mode\")\n",
	"]]\n",
	"{\n",
	"    wrap_periodic = 0 [[ \n",
	"        anno::display_name(\"Periodic\") \n",
	"    ]],\n",
	"\n",
	"    wrap_clamp = 2 [[ \n",
	"        anno::display_name(\"Clamp\") \n",
	"    ]],\n",
	"\n",
	"    wrap_mirror = 3 [[ \n",
	"        anno::display_name(\"Mirror\") \n",
	"    ]],\n",
	"\n",
	"    wrap_missing = 5 [[ \n",
	"        anno::display_name(\"Missing\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"export enum alpha_mode \n",
	"[[ \n",
	"    anno::description(\"Alpha mode\")\n",
	"]]\n",
	"{\n",
	"    alpha_default = 0 [[ \n",
	"        anno::display_name(\"Default\") \n",
	"    ]],\n",
	"\n",
	"    alpha_red = 1 [[ \n",
	"        anno::display_name(\"Red\") \n",
	"    ]],\n",
	"\n",
	"    alpha_green = 2 [[ \n",
	"        anno::display_name(\"Green\") \n",
	"    ]],\n",
	"\n",
	"    alpha_blue = 3 [[ \n",
	"        anno::display_name(\"Blue\") \n",
	"    ]],\n",
	"\n",
	"    alpha_white = 4 [[ \n",
	"        anno::display_name(\"White\") \n",
	"    ]],\n",
	"\n",
	"    alpha_black = 5 [[ \n",
	"        anno::display_name(\"Black\") \n",
	"    ]],\n",
	"\n",
	"    alpha_luminance = 6 [[ \n",
	"        anno::display_name(\"Luminance\") \n",
	"    ]],\n",
	"\n",
	"    alpha_average = 7  [[ \n",
	"        anno::display_name(\"Average\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"export uniform alpha_mode alpha_from_mono_mode( uniform ::base::mono_mode mode) \n",
	"{\n",
	"  switch ( mode){\n",
	"  case ::base::mono_alpha:     return alpha_default;\n",
	"  case ::base::mono_average:   return alpha_average;\n",
	"  case ::base::mono_luminance: return alpha_luminance;\n",
	"  default: break;\n",
	"  }\n",
	"  return alpha_luminance;\n",
	"}\n",
	"\n",
	"export struct texture_lookup_data\n",
	"{\n",
	"    color tint = color(0.0);\n",
	"    float mono = 0.0f;\n",
	"    float3 normal = float3(0.0f);\n",
	"};\n",
	"\n",
	"\n",
	"export base::texture_coordinate_info compute_texture_coordinate(\n",
	"    uniform base::texture_coordinate_system texture_coordinate_system = base::texture_coordinate_world,\n",
	"    uniform int uv_set = 0,\n",
	"    uniform float s_offset = 0.0f,\n",
	"    uniform float t_offset = 0.0f,\n",
	"    uniform float s_scale = 1.0f,\n",
	"    uniform float t_scale = 1.0f,\n",
	"    uniform bool s_flip = false,\n",
	"    uniform bool t_flip = false,\n",
	"    uniform bool swap_st = false,\n",
	"    uniform base::projection_mode projection_mode = base::projection_cubic,\n",
	"    uniform float3 projection_translate = float3(0.0),\n",
	"    uniform float3 projection_rotate = float3(0.0),\n",
	"    uniform float3 projection_scale = float3(1.0)\n",
	") varying \n",
	"{\n",
	"    base::texture_coordinate_info texture_coordinate_info = \n",
	"        (texture_coordinate_system == base::texture_coordinate_uvw) ?\n",
	"            base::coordinate_source(base::texture_coordinate_uvw, uv_set) :\n",
	"            base::coordinate_projection(\n",
	"                texture_coordinate_system,\n",
	"                uv_set, \n",
	"                projection_mode,\n",
	"                base::rotation_translation_scale(\n",
	"                    projection_translate,\n",
	"                    projection_rotate,\n",
	"                    projection_scale));\n",
	"\n",
	"    //transform\n",
	"    float4x4 scale(\n",
	"        s_scale, 0.0, 0.0, 0.0,\n",
	"        0.0, t_scale, 0.0, 0.0,\n",
	"        0.0, 0.0, 1.0, 0.0,\n",
	"        0.0, 0.0, 0.0, 1.0);\n",
	"\n",
	"    float4 position = \n",
	"        scale * float4(\n",
	"            swap_st ? \n",
	"                texture_coordinate_info.position.y + s_offset : \n",
	"                texture_coordinate_info.position.x + s_offset,\n",
	"\n",
	"            swap_st ? \n",
	"                texture_coordinate_info.position.x + t_offset : \n",
	"                texture_coordinate_info.position.y + t_offset,\n",
	"\n",
	"            texture_coordinate_info.position.z, \n",
	"            1.0\n",
	"        );\n",
	"\n",
	"    texture_coordinate_info.position = float3(\n",
	"        s_flip ? -position.x : position.x, \n",
	"        t_flip ? -position.y : position.y, \n",
	"        position.z);\n",
	"\n",
	"    return texture_coordinate_info;\n",
	"}\n",
	"\n",
	"// Adding nearest neighbour lookup computation\n",
	"float3 texture_lookup_nn( int2 tex_size, float3 coords)\n",
	"{\n",
	"    float2 smooth = float2( coords.x, coords.y);\n",
	"    float2 quant = (math::floor(smooth * tex_size) + float2( 0.5, 0.5)) / tex_size;\n",
	"    return float3( quant.x, quant.y, coords.z);\n",
	"}\n",
	"\n",
	"struct wrap_result\n",
	"{\n",
	"    float coord;\n",
	"    bool  flipped; \n",
	"};\n",
	"\n",
	"// Implement wrap mode by hand\n",
	"wrap_result texture_lookup_wrap( uniform wrap_mode wrap, float coord)\n",
	"{\n",
	"    bool flipped = false;\n",
	"    switch (wrap)\n",
	"    {\n",
	"        case wrap_periodic:\n",
	"            coord = math::frac( coord);\n",
	"            break;\n",
	"        case wrap_clamp:\n",
	"            coord = math::clamp( coord, 0.0, 0.999999);\n",
	"            break;\n",
	"        case wrap_mirror:\n",
	"            coord = math::frac( coord / 2.0) * 2.0;\n",
	"            if ( coord >= 1.0) {\n",
	"                coord = math::clamp( 2.0 - coord, 0.0, 0.999999);\n",
	"                flipped = true;\n",
	"            }\n",
	"            break;\n",
	"        case wrap_missing:\n",
	"            break;\n",
	"    }\n",
	"    return wrap_result( coord, flipped);\n",
	"}\n",
	"\n",
	"export texture_lookup_data texture_lookup_2_smooth(\n",
	"    uniform texture_2d texture = texture_2d(),\n",
	"    color missing_color = color(0.0),\n",
	"    uniform wrap_mode s_wrap = wrap_periodic,\n",
	"    uniform wrap_mode t_wrap = wrap_periodic,\n",
	"    base::texture_coordinate_info texture_coordinate_info = base::texture_coordinate_info()\n",
	")\n",
	"{\n",
	"    tex::wrap_mode s_wrap_native = tex::wrap_clip;\n",
	"    switch (s_wrap)\n",
	"    {\n",
	"        case wrap_periodic:\n",
	"            s_wrap_native = tex::wrap_repeat;\n",
	"            break;\n",
	"        case wrap_clamp:\n",
	"            s_wrap_native = tex::wrap_clamp;\n",
	"            break;\n",
	"        case wrap_mirror:\n",
	"            s_wrap_native = tex::wrap_mirrored_repeat;\n",
	"            break;\n",
	"        case wrap_missing:\n",
	"            if (texture_coordinate_info.position.x < 0.0f || \n",
	"                texture_coordinate_info.position.x > 1.0f)\n",
	"            {\n",
	"                return texture_lookup_data(missing_color, 0.0f, float3(0.0));\n",
	"            }\n",
	"    }\n",
	"\n",
	"    tex::wrap_mode t_wrap_native = tex::wrap_clip;\n",
	"    switch (t_wrap)\n",
	"    {\n",
	"        case wrap_periodic:\n",
	"            t_wrap_native = tex::wrap_repeat;\n",
	"            break;\n",
	"        case wrap_clamp:\n",
	"            t_wrap_native = tex::wrap_clamp;\n",
	"            break;\n",
	"        case wrap_mirror:\n",
	"            t_wrap_native = tex::wrap_mirrored_repeat;\n",
	"            break;\n",
	"        case wrap_missing:\n",
	"            if (texture_coordinate_info.position.y < 0.0f || \n",
	"                texture_coordinate_info.position.y > 1.0f)\n",
	"            {\n",
	"                return texture_lookup_data(missing_color, 0.0f, float3(0.0));\n",
	"            }\n",
	"    }\n",
	"\n",
	"    float4 result = tex::lookup_float4(\n",
	"        texture, \n",
	"        float2(texture_coordinate_info.position.x, texture_coordinate_info.position.y), \n",
	"        s_wrap_native,\n",
	"        t_wrap_native,\n",
	"        float2(0.0, 1.0),\n",
	"        float2(0.0, 1.0));\n",
	"\n",
	"    return texture_lookup_data(\n",
	"        color(result.x, result.y, result.z), \n",
	"        result.w, \n",
	"        float3(0.0));\n",
	"}\n",
	"\n",
	"\n",
	"export texture_lookup_data texture_lookup_2(\n",
	"    uniform texture_2d texture = texture_2d(),\n",
	"    uniform bool ignore_missing_texture = false,\n",
	"    color missing_color = color(0.0),\n",
	"    uniform bool use_uv_coords = false,\n",
	"    float2 uv_coords = float2(0.0),\n",
	"    uniform wrap_mode s_wrap = wrap_periodic,\n",
	"    uniform wrap_mode t_wrap = wrap_periodic,\n",
	"    uniform bool filtered_textures = false,\n",
	"    base::texture_coordinate_info texture_coordinate_info = base::texture_coordinate_info()\n",
	")\n",
	"{\n",
	"    if (ignore_missing_texture && tex::texture_isvalid(texture) == false)\n",
	"    {\n",
	"        return texture_lookup_data(missing_color, 0.0f, float3(0.0));\n",
	"    }\n",
	"    int2 tex_size( tex::width(texture), tex::height(texture));\n",
	"\n",
	"    if ((tex_size.x == 0) || (tex_size.y == 0))\n",
	"    {\n",
	"        return texture_lookup_data(missing_color, 0.0f, float3(0.0));\n",
	"    }\n",
	"\n",
	"    if (use_uv_coords)\n",
	"    {\n",
	"        texture_coordinate_info.position.x = uv_coords[0];\n",
	"        texture_coordinate_info.position.y = uv_coords[1];\n",
	"    }\n",
	"\n",
	"    if ( filtered_textures)\n",
	"        return texture_lookup_2_smooth(\n",
	"            texture,\n",
	"	    missing_color,\n",
	"	    s_wrap, t_wrap, texture_coordinate_info);\n",
	"				       \n",
	"    texture_coordinate_info.position.x = \n",
	"        texture_lookup_wrap( s_wrap, texture_coordinate_info.position.x).coord;\n",
	"\n",
	"    if (texture_coordinate_info.position.x < 0.0f || \n",
	"        texture_coordinate_info.position.x >= 1.0f)\n",
	"    {\n",
	"        return texture_lookup_data( missing_color, 0.0f, float3(0.0));\n",
	"    }\n",
	"\n",
	"    texture_coordinate_info.position.y = \n",
	"        texture_lookup_wrap( t_wrap, texture_coordinate_info.position.y).coord;\n",
	"\n",
	"    if (texture_coordinate_info.position.y < 0.0f || \n",
	"        texture_coordinate_info.position.y >= 1.0f)\n",
	"    {\n",
	"        return texture_lookup_data( missing_color, 0.0f, float3(0.0));\n",
	"    }\n",
	"\n",
	"    texture_coordinate_info.position = \n",
	"        texture_lookup_nn( tex_size, texture_coordinate_info.position);\n",
	"\n",
	"    int2 int_coord = int2( int( texture_coordinate_info.position.x * tex_size.x),\n",
	"                           int( texture_coordinate_info.position.y * tex_size.y));\n",
	"    float4 result = tex::texel_float4( tex: texture, coord: int_coord);\n",
	"\n",
	"    return texture_lookup_data(\n",
	"        color(result.x, result.y, result.z), \n",
	"        result.w, \n",
	"        float3(0.0));\n",
	"}\n",
	"\n",
	"\n",
	"export texture_lookup_data normal_lookup_2(\n",
	"    uniform texture_2d texture = texture_2d(),\n",
	"    uniform bool ignore_missing_texture = false,\n",
	"    color missing_color = color(0.0),\n",
	"    uniform bool use_uv_coords = false,\n",
	"    float2 uv_coords = float2(0.0),\n",
	"    uniform wrap_mode s_wrap = wrap_periodic,\n",
	"    uniform wrap_mode t_wrap = wrap_periodic,\n",
	"    uniform bool s_flip = false,\n",
	"    uniform bool t_flip = false,\n",
	"    uniform float tangent_space_factor = 1.0f,\n",
	"    uniform bool tangent_space_flip_r_channel = false,\n",
	"    uniform bool tangent_space_flip_g_channel = false,\n",
	"    uniform bool tangent_space_flip_b_channel = false,\n",
	"    uniform bool filtered_textures = false [[ anno::unused() ]], // not yet implemented\n",
	"    base::texture_coordinate_info texture_coordinate_info = base::texture_coordinate_info()\n",
	")\n",
	"{\n",
	"    if ((ignore_missing_texture && tex::texture_isvalid(texture) == false) ||\n",
	"        (tex::width(texture) == 0) || (tex::height(texture) == 0))\n",
	"    {\n",
	"        return texture_lookup_data(\n",
	"            missing_color,\n",
	"            0.0f,\n",
	"            math::normalize(\n",
	"                texture_coordinate_info.tangent_u +\n",
	"                texture_coordinate_info.tangent_v +\n",
	"                state::normal()));\n",
	"    }\n",
	"\n",
	"    if (use_uv_coords)\n",
	"    {\n",
	"        texture_coordinate_info.position.x = uv_coords[0];\n",
	"        texture_coordinate_info.position.y = uv_coords[1];\n",
	"    }\n",
	"\n",
	"    wrap_result s_wrap_result = \n",
	"        texture_lookup_wrap( s_wrap, texture_coordinate_info.position.x);\n",
	"    texture_coordinate_info.position.x = s_wrap_result.coord;\n",
	"\n",
	"    if (texture_coordinate_info.position.x < 0.0f || \n",
	"        texture_coordinate_info.position.x >= 1.0f)\n",
	"    {\n",
	"        return texture_lookup_data(\n",
	"            missing_color,\n",
	"            0.0f,\n",
	"            math::normalize(\n",
	"                texture_coordinate_info.tangent_u +\n",
	"                texture_coordinate_info.tangent_v +\n",
	"                state::normal()));\n",
	"    }\n",
	"\n",
	"    wrap_result t_wrap_result = \n",
	"        texture_lookup_wrap( t_wrap, texture_coordinate_info.position.y);\n",
	"    texture_coordinate_info.position.y = t_wrap_result.coord; \n",
	"\n",
	"    if (texture_coordinate_info.position.y < 0.0f || \n",
	"        texture_coordinate_info.position.y >= 1.0f)\n",
	"    {\n",
	"        return texture_lookup_data(\n",
	"            missing_color,\n",
	"            0.0f,\n",
	"            math::normalize(\n",
	"                texture_coordinate_info.tangent_u +\n",
	"                texture_coordinate_info.tangent_v +\n",
	"                state::normal()));\n",
	"    }\n",
	"\n",
	"    int2 tex_size( tex::width(texture), tex::height(texture));\n",
	"    texture_coordinate_info.position = \n",
	"        texture_lookup_nn( tex_size, texture_coordinate_info.position);\n",
	"\n",
	"    //If mirror repeat was selected for tangent space texture, tangent space \n",
	"    //needs to be flipped for every other tile. Please note this is not matching \n",
	"    //with Arnold's aiImage but it would make sense to have like this.\n",
	"    bool local_s_flip = (s_flip != s_wrap_result.flipped);\n",
	"    bool local_t_flip = (t_flip != t_wrap_result.flipped);\n",
	"\n",
	"    float3 transformed_tangent_u = texture_coordinate_info.tangent_u;\n",
	"    float3 transformed_tangent_v = texture_coordinate_info.tangent_v;\n",
	"\n",
	"    if (local_s_flip)\n",
	"        transformed_tangent_u = -transformed_tangent_u;\n",
	"    \n",
	"    if (local_t_flip)\n",
	"        transformed_tangent_v = -transformed_tangent_v;\n",
	"\n",
	"    int2 int_coord = int2( int( texture_coordinate_info.position.x * tex_size.x),\n",
	"                           int( texture_coordinate_info.position.y * tex_size.y));\n",
	"    float3 result = tex::texel_float3( tex: texture, coord: int_coord);\n",
	"\n",
	"    if (tangent_space_flip_r_channel)\n",
	"        result.x = 1.0f - result.x;\n",
	"\n",
	"    if (!tangent_space_flip_g_channel)\n",
	"        result.y = 1.0f - result.y;\n",
	"\n",
	"    if (tangent_space_flip_b_channel)\n",
	"        result.z = 1.0f - result.z;\n",
	"\n",
	"    result = (result - float3(0.5)) * (2.0f * tangent_space_factor);\n",
	"\n",
	"    return texture_lookup_data(\n",
	"        color(0.0),\n",
	"        0.0f,\n",
	"        math::normalize(\n",
	"                transformed_tangent_u * result.x +\n",
	"                transformed_tangent_v * result.y +\n",
	"                state::normal() * (result.z + (1.0f - tangent_space_factor)))\n",
	"        );\n",
	"}\n",
	"\n",
	"\n",
	"export enum tangent_bitangent_mapping\n",
	"[[ \n",
	"    anno::description(\"Tangent and bitangent mapping mode\")\n",
	"]]\n",
	"{\n",
	"    red_green = 1 [[ \n",
	"        anno::display_name(\"Red Green\") \n",
	"    ]],\n",
	"\n",
	"    blue_green = 9 [[ \n",
	"        anno::display_name(\"Red Blue\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"\n",
	"export float3 normal_mapping(\n",
	"    varying float3 normal = float3(0.0, 0.0, 1.0),\n",
	"    uniform tangent_bitangent_mapping tangent_bitangent_mapping = red_green,\n",
	"    varying float3 normal_camera = state::normal()\n",
	"\n",
	") varying {\n",
	"\n",
	"    if (math::length(normal) > 0.0f)\n",
	"    {\n",
	"        int ti = tangent_bitangent_mapping/4;\n",
	"        int bi = tangent_bitangent_mapping&3;\n",
	"        return float3(normal[ti], normal[bi], normal[3-ti-bi]);\n",
	"    }\n",
	"\n",
	"    return normal_camera;\n",
	"}\n",
	"\n",
	"export texture_lookup_data texture_adjustment(\n",
	"    texture_lookup_data texture_data,\n",
	"    float exposure = 0.0f,\n",
	"    color default_color = color(0.5),\n",
	"    color color_gain = color(1.0),\n",
	"    color color_offset = color(0.0),\n",
	"    float alpha_gain = 1.0f,\n",
	"    float alpha_offset = 0.0f,\n",
	"    uniform alpha_mode alpha_source = alpha_default,\n",
	"    uniform bool invert = false,\n",
	"    float blend_factor = 0.0f\n",
	"\n",
	") {\n",
	"    color tint = texture_data.tint;\n",
	"    float3 tint3f = float3(tint);\n",
	"    float mono;\n",
	"    switch (alpha_source) \n",
	"    {\n",
	"        case alpha_default:\n",
	"            mono = texture_data.mono;\n",
	"            break;\n",
	"\n",
	"        case alpha_red:\n",
	"            mono = tint3f.x;\n",
	"            break;\n",
	"\n",
	"        case alpha_green:\n",
	"            mono = tint3f.y;\n",
	"            break;\n",
	"\n",
	"        case alpha_blue:\n",
	"            mono = tint3f.z;\n",
	"            break;\n",
	"\n",
	"        case alpha_white:\n",
	"            mono = 1.0f;\n",
	"            break;\n",
	"\n",
	"        case alpha_black:\n",
	"            mono = 0.0f;\n",
	"            break;\n",
	"\n",
	"        case alpha_luminance:\n",
	"            mono = math::luminance(tint);\n",
	"            break;\n",
	"\n",
	"        case alpha_average:\n",
	"            mono = math::average(tint);\n",
	"            break;\n",
	"    }\n",
	"\n",
	"    tint = math::pow(2.0, exposure) * tint;\n",
	"\n",
	"    if (invert)\n",
	"    {\n",
	"        tint = color(1.0) - tint;\n",
	"        mono = 1.0f - mono;\n",
	"    }\n",
	"\n",
	"    tint = tint * color_gain + color_offset;\n",
	"    mono = mono * alpha_gain + alpha_offset;\n",
	"    \n",
	"    tint = math::lerp(tint, default_color, blend_factor);\n",
	"    mono = mono * (1.0f - blend_factor);\n",
	"\n",
	"    return texture_lookup_data(tint, mono, texture_data.normal);\n",
	"}\n",
};

const char* file_OmniShared[] = {
	"/***************************************************************************************************\n",
	" * Copyright 2020 NVIDIA Corporation. All rights reserved.\n",
	" *\n",
	" * Redistribution and use in source and binary forms, with or without\n",
	" * modification, are permitted provided that the following conditions\n",
	" * are met:\n",
	" *  * Redistributions of source code must retain the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer.\n",
	" *  * Redistributions in binary form must reproduce the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer in the\n",
	" *    documentation and/or other materials provided with the distribution.\n",
	" *  * Neither the name of NVIDIA CORPORATION nor the names of its\n",
	" *    contributors may be used to endorse or promote products derived\n",
	" *    from this software without specific prior written permission.\n",
	" *\n",
	" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n",
	" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n",
	" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n",
	" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n",
	" * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n",
	" * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n",
	" * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n",
	" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n",
	" * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n",
	" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n",
	" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
	" **************************************************************************************************/\n",
	"\n",
	"// Omni's shared utilities\n",
	"\n",
	"mdl 1.6;\n",
	"\n",
	"import ::anno::*;\n",
	"import ::math::*;\n",
	"import ::state::*;\n",
	"\n",
	"export struct metal_complex_ior\n",
	"{\n",
	"    color n; //refractive index\n",
	"    color k; //extinction coefficient\n",
	"};\n",
	"\n",
	"//[Gulbrandsen2014] Ole Gulbrandsen, 2014. Artist friendly metallic fresnel.\n",
	"export metal_complex_ior compute_artistic_to_conductor_fresnel(\n",
	"    color reflectivity,\n",
	"    color edge_tint)\n",
	"{\n",
	"    color r = math::clamp(reflectivity, color(0.0f), color(0.99f));\n",
	"    color g = edge_tint;\n",
	"\n",
	"    color r_sqrt = math::sqrt(r);\n",
	"    color n_min = (1.0f - r) / (1.0f + r);\n",
	"    color n_max = (1.0f + r_sqrt) / (1.0f - r_sqrt);\n",
	"\n",
	"    color n = math::lerp(n_max, n_min, g);\n",
	"\n",
	"    color k2 = ((n + 1.0f) * (n + 1.0f) * r - (n - 1.0f) * (n - 1.0f)) / (1.0f - r);\n",
	"    k2 = math::max(k2, 0.0f);\n",
	"    color k = math::sqrt(k2);\n",
	"\n",
	"    return metal_complex_ior(n, k);\n",
	"}\n",
	"\n",
	"export float2 compute_anisotropy(float roughness, float anisotropy)\n",
	"{\n",
	"    float r = math::sqrt(1.0f - math::clamp(anisotropy, 0.0f, 0.98f));\n",
	"    return float2(math::min(roughness / r, 1.0f), roughness * r);\n",
	"}\n",
	"\n",
	"export float compute_reflection_from_ior(float ior)\n",
	"{\n",
	"    return ((1.0f - ior) * (1.0f - ior)) / ((1.0f + ior) * (1.0f + ior));\n",
	"}\n",
	"\n",
	"export struct fresnel_reflectivity\n",
	"{\n",
	"    float nr; //normal reflectivity\n",
	"    float gr; //grazing reflectivity\n",
	"};\n",
	"\n",
	"export fresnel_reflectivity approximate_fresnel(float ior, float roughness)\n",
	"{\n",
	"    float r = (ior - 1.0f) / (ior + 1.0f);\n",
	"    float nr = r * r;\n",
	"    float gr = math::max((1.0 - roughness), 0.0);\n",
	"\n",
	"    return fresnel_reflectivity(nr, gr);\n",
	"}\n",
	"\n",
	"export float3 rotate_tangent(float3 tangent, float rotation)\n",
	"{\n",
	"    float rot_angle = -2.0f * math::PI * rotation;\n",
	"    float3 bitangent = math::normalize(math::cross(state::normal(), tangent));\n",
	"    float cos_rot_angle = math::cos(rot_angle);\n",
	"    float sin_rot_angle = math::sin(rot_angle);\n",
	"    return cos_rot_angle * tangent - sin_rot_angle * bitangent;\n",
	"}\n",
	"\n",
	"//https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides_v2.pdf\n",
	"//Phase function eccentricity 'g' has been omitted here since we pass that directly \n",
	"//to anisotropic_vdf(directional_bias: g).\n",
	"export color compute_transmission_albedo(color transmission_color)\n",
	"{\n",
	"    return color(4.09712) +\n",
	"           (4.20863f * transmission_color) -\n",
	"           math::sqrt(\n",
	"               9.59217f +\n",
	"               41.6808f * transmission_color +\n",
	"               17.7126f * transmission_color * transmission_color);\n",
	"}\n",
	"\n",
	"export struct volume_coefficients\n",
	"{\n",
	"    color scattering;\n",
	"    color absorption;\n",
	"};\n",
	"\n",
	"export volume_coefficients compute_subsurface_volume_coefficients(\n",
	"    color transmission_color,\n",
	"    color scattering_color,\n",
	"    float g,\n",
	"    float scale)\n",
	"{\n",
	"    color s = compute_transmission_albedo(transmission_color);\n",
	"    color alpha = (color(1.0) - s * s) / (color(1.0) - g * (s * s));\n",
	"    color scattering_coefficient = alpha / (scale * scattering_color);\n",
	"    color absorption_coefficient =\n",
	"        (color(1.0) / (scale * scattering_color)) - scattering_coefficient;\n",
	"\n",
	"    return volume_coefficients(scattering_coefficient, absorption_coefficient);\n",
	"}\n",
	"\n",
	"export volume_coefficients compute_transmission_volume_coefficients(\n",
	"    color transmission_color,\n",
	"    color scattering_color,\n",
	"    float scattering_depth)\n",
	"{\n",
	"    float offset = 1.0f + math::max_value(scattering_color);\n",
	"    color scattering_coefficient =\n",
	"        math::log(transmission_color / offset) / (-1.0f * scattering_depth);\n",
	"    color s = compute_transmission_albedo(scattering_color);\n",
	"\n",
	"    color s2 = s * s;\n",
	"    color absorption_coefficient = scattering_coefficient * s2;\n",
	"    return volume_coefficients(\n",
	"        scattering_coefficient - absorption_coefficient,\n",
	"        absorption_coefficient);\n",
	"}\n",
	"\n",
	"export enum subsurface_scattering_type\n",
	"[[\n",
	"    anno::description(\"Subsurface scattering type\")]]\n",
	"{\n",
	"    random_walk = 0 [[ \n",
	"        anno::display_name(\"Randomwalk\") \n",
	"    ]],\n",
	"\n",
	"    random_walk_v2 = 1 [[ \n",
	"        anno::display_name(\"Randomwalk v2\") \n",
	"    ]],\n",
	"\n",
	"    fast_sss = 2 [[ \n",
	"        anno::display_name(\"Use Fast SSS\") \n",
	"    ]],\n",
	"\n",
	"    procedural_vol = 4 [[ \n",
	"        anno::display_name(\"Procedural Volume\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"export struct scattering_colors\n",
	"{\n",
	"    color scattering_transmission_color;\n",
	"    color scattering_scattering_color; //radius, not a typo here.\n",
	"};\n",
	"\n",
	"export enum scattering_colors_presets\n",
	"[[ \n",
	"    anno::description(\"Scattering transmission color and radius presets\")\n",
	"]]\n",
	"{\n",
	"    scattering_colors_apple = 0 [[ \n",
	"        anno::display_name(\"Apple\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_chicken = 1 [[ \n",
	"        anno::display_name(\"Chicken\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_cream = 2 [[ \n",
	"        anno::display_name(\"Cream\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_ketchup = 3 [[ \n",
	"        anno::display_name(\"Ketchup\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_marble = 4 [[ \n",
	"        anno::display_name(\"Marble\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_potato = 5 [[ \n",
	"        anno::display_name(\"Potato\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_skim_milk = 6 [[ \n",
	"        anno::display_name(\"Skim Milk\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_whole_milk = 7 [[ \n",
	"        anno::display_name(\"Whole Milk\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_skin_1 = 8 [[ \n",
	"        anno::display_name(\"Skin 1\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_skin_2 = 9 [[ \n",
	"        anno::display_name(\"Skin 2\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_skin_3 = 10 [[ \n",
	"        anno::display_name(\"Skin 3\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_skin_4 = 11 [[ \n",
	"        anno::display_name(\"Skin 4\") \n",
	"    ]],\n",
	"\n",
	"    scattering_colors_custom = 12 [[ \n",
	"        anno::display_name(\"Custom\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"// Values are from Henrik Wann Jensen, Stephen R. Marschner, Marc Levoy, and \n",
	"// Pat Hanrahan. A Practical Model for Subsurface Light Transport. Proceedings \n",
	"// of SIGGRAPH 2001, pages 511-518.\n",
	"export scattering_colors scattering_colors_preset_to_value(\n",
	"    scattering_colors_presets preset, \n",
	"    color scattering_transmission_color = color(1.0),\n",
	"    color scattering_scattering_color = color(1.0))\n",
	"[[\n",
	"    anno::description(\"Return scattering colors based on preset.\")\n",
	"]]\n",
	"{\n",
	"    if (preset == scattering_colors_apple)\n",
	"        return scattering_colors(\n",
	"            color(0.430, 0.210, 0.170), \n",
	"            color(11.610, 3.880, 1.750));\n",
	"\n",
	"    if (preset == scattering_colors_chicken)\n",
	"        return scattering_colors(\n",
	"            color(0.440, 0.220, 0.140), \n",
	"            color(9.440, 3.350, 1.790));\n",
	"\n",
	"     if (preset == scattering_colors_cream)\n",
	"         return scattering_colors(\n",
	"             color(0.990, 0.940, 0.830), \n",
	"             color(15.030, 4.660, 2.540));\n",
	"\n",
	"    if (preset == scattering_colors_ketchup)\n",
	"        return scattering_colors(\n",
	"            color(0.220, 0.010, 0.001), \n",
	"            color(4.760, 0.570, 0.390));\n",
	"\n",
	"    if (preset == scattering_colors_marble)\n",
	"        return scattering_colors(\n",
	"            color(0.930, 0.910, 0.880), \n",
	"            color(8.510, 5.570, 3.950));\n",
	"\n",
	"    if (preset == scattering_colors_potato)\n",
	"        return scattering_colors(\n",
	"            color(0.860, 0.740, 0.290), \n",
	"            color(14.270, 7.230, 2.040));\n",
	"\n",
	"    if (preset == scattering_colors_skim_milk)\n",
	"        return scattering_colors(\n",
	"            color(0.890, 0.890, 0.800), \n",
	"            color(18.420, 10.440, 3.500));\n",
	"\n",
	"    if (preset == scattering_colors_whole_milk)\n",
	"        return scattering_colors(\n",
	"            color(0.950, 0.930, 0.850), \n",
	"            color(10.900, 6.580, 2.510));\n",
	"\n",
	"    if (preset == scattering_colors_skin_1)\n",
	"        return scattering_colors(\n",
	"            color(0.570, 0.310, 0.170), \n",
	"            color(3.670, 1.370, 0.680));\n",
	"\n",
	"    if (preset == scattering_colors_skin_2)\n",
	"        return scattering_colors(\n",
	"            color(0.750, 0.570, 0.470), \n",
	"            color(4.820, 1.690, 1.090));\n",
	"\n",
	"    if (preset == scattering_colors_skin_3)\n",
	"        return scattering_colors(\n",
	"            color(0.999, 0.615, 0.521), \n",
	"            color(1.000, 0.300, 0.100));\n",
	"\n",
	"    if (preset == scattering_colors_skin_4)\n",
	"        return scattering_colors(\n",
	"            color(0.078, 0.043, 0.025), \n",
	"            color(0.723, 0.264, 0.127));\n",
	"\n",
	"    return scattering_colors(\n",
	"        scattering_transmission_color,\n",
	"        scattering_scattering_color);\n",
	"}\n",
	"\n",
	"export enum ior_presets\n",
	"[[ \n",
	"    anno::description(\"Index of refraction preset\")\n",
	"]]\n",
	"{\n",
	"    ior_cornea = 0 [[ \n",
	"        anno::display_name(\"Cornea\") \n",
	"    ]],\n",
	"\n",
	"    ior_diamond = 1 [[ \n",
	"        anno::display_name(\"Diamond\") \n",
	"    ]],\n",
	"\n",
	"    ior_ethanol = 2 [[ \n",
	"        anno::display_name(\"Ethanol\") \n",
	"    ]],\n",
	"\n",
	"    ior_flint_glass = 3 [[ \n",
	"        anno::display_name(\"Flint Glass\") \n",
	"    ]],\n",
	"\n",
	"    ior_glass = 4 [[ \n",
	"        anno::display_name(\"Glass\") \n",
	"    ]],\n",
	"\n",
	"    ior_ice = 5 [[ \n",
	"        anno::display_name(\"Ice\") \n",
	"    ]],\n",
	"\n",
	"    ior_olive_oil = 6 [[ \n",
	"        anno::display_name(\"Olive Oil\") \n",
	"    ]],\n",
	"\n",
	"    ior_plastic = 7 [[ \n",
	"        anno::display_name(\"Plastic\") \n",
	"    ]],\n",
	"\n",
	"    ior_sapphire = 8 [[ \n",
	"        anno::display_name(\"Sapphire\") \n",
	"    ]],\n",
	"\n",
	"    ior_skin = 9 [[ \n",
	"        anno::display_name(\"Skin\") \n",
	"    ]],\n",
	"\n",
	"    ior_water = 10 [[ \n",
	"        anno::display_name(\"Water\") \n",
	"    ]],\n",
	"\n",
	"    ior_custom = 11 [[ \n",
	"        anno::display_name(\"Custom\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"export float ior_preset_to_value(\n",
	"    ior_presets preset, \n",
	"    uniform float custom = 1.0f) uniform\n",
	"[[\n",
	"    anno::description(\"Return ior value based on preset.\")\n",
	"]]\n",
	"{\n",
	"    if (preset == ior_cornea)\n",
	"        return 1.37f;\n",
	"\n",
	"    if (preset == ior_diamond)\n",
	"        return 2.42f;\n",
	"\n",
	"    if (preset == ior_ethanol)\n",
	"        return 1.36f;\n",
	"\n",
	"    if (preset == ior_flint_glass)\n",
	"        return 1.6f;\n",
	"\n",
	"    if (preset == ior_glass)\n",
	"        return 1.5f;\n",
	"\n",
	"    if (preset == ior_ice)\n",
	"        return 1.31f;\n",
	"\n",
	"    if (preset == ior_olive_oil)\n",
	"        return 1.47f;\n",
	"\n",
	"    if (preset == ior_plastic)\n",
	"        return 1.55f;\n",
	"\n",
	"    if (preset == ior_sapphire)\n",
	"        return 1.77f;\n",
	"\n",
	"    if (preset == ior_skin)\n",
	"        return 1.4f;\n",
	"\n",
	"    if (preset == ior_water)\n",
	"        return 1.33f;\n",
	"\n",
	"    return custom;\n",
	"}\n",
	"\n",
	"float3 transform_internal_to_tangent(float3 n)\n",
	"{\n",
	"    return\n",
	"        n.x * float3(\n",
	"            state::texture_tangent_u(0).x,\n",
	"            state::texture_tangent_v(0).x, \n",
	"            state::normal().x) +\n",
	"\n",
	"        n.y * float3(\n",
	"            state::texture_tangent_u(0).y, \n",
	"            state::texture_tangent_v(0).y,\n",
	"            state::normal().y) +\n",
	"\n",
	"        n.z * float3(\n",
	"            state::texture_tangent_u(0).z,\n",
	"            state::texture_tangent_v(0).z,\n",
	"            state::normal().z);\n",
	"}\n",
	"\n",
	"float3 transform_tangent_to_internal(float3 n)\n",
	"{\n",
	"    return\n",
	"        state::texture_tangent_u(0) * n.x +\n",
	"        state::texture_tangent_v(0) * n.y +\n",
	"        state::normal() * n.z ;\n",
	"}\n",
	"\n",
	"export float3 add_detail_normal(\n",
	"    float3 nd = state::normal(), \n",
	"    float3 n = state::normal())\n",
	"{\n",
	"    float3 n_t = transform_internal_to_tangent(n);\n",
	"    float3 nd_t = transform_internal_to_tangent(nd);\n",
	"\n",
	"    n_t = n_t + float3(0.0, 0.0, 1.0);\n",
	"    nd_t = nd_t *  float3(-1.0, -1.0, 1.0);\n",
	"\n",
	"    n = n_t * math::dot(n_t, nd_t) / n_t.z - nd_t;\n",
	"    return math::normalize(transform_tangent_to_internal(n));\n",
	"}\n",
	"\n",
	"\n",
	"export enum normal_mode\n",
	"[[ \n",
	"    anno::description(\"Normal Mode\")\n",
	"]]\n",
	"{\n",
	"    normal_tangent_space = 0 [[ \n",
	"        anno::display_name(\"Tangent Space\") \n",
	"    ]],\n",
	"\n",
	"    normal_object_space = 1 [[ \n",
	"        anno::display_name(\"Object Space\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"\n",
	"export enum displacement_mode\n",
	"[[ \n",
	"    anno::description(\"Displacement Mode\")\n",
	"]]\n",
	"{\n",
	"    displacement_height = 0 [[ \n",
	"        anno::display_name(\"Height\") \n",
	"    ]],\n",
	"\n",
	"    displacement_vector_tangent_space = 1 [[ \n",
	"        anno::display_name(\"Vector, Tangent Space\") \n",
	"    ]],\n",
	"\n",
	"    displacement_vector_object_space = 2 [[ \n",
	"        anno::display_name(\"Vector, Object Space\") \n",
	"    ]],\n",
	"\n",
	"    displacement_vector_world_space = 3 [[ \n",
	"        anno::display_name(\"Vector, World Space\") \n",
	"    ]]\n",
	"};\n",
	"\n",
	"\n",
	"export float3 displacement_adjustment(\n",
	"    float3 displacement = float3(0.0),\n",
	"    uniform displacement_mode mode = displacement_height,\n",
	"    float scale = 1.0f) \n",
	"{\n",
	"    float3 result;\n",
	"    switch (mode) \n",
	"    {\n",
	"        case displacement_height:\n",
	"            result = state::normal() * displacement * scale;\n",
	"            break;\n",
	"\n",
	"        case displacement_vector_tangent_space:\n",
	"            result = \n",
	"                state::texture_tangent_u(0) * displacement[0] * scale +\n",
	"                state::texture_tangent_v(0) * displacement[2] * scale +\n",
	"                state::normal() * displacement[1] * scale;\n",
	"            break;\n",
	"\n",
	"        case displacement_vector_object_space:\n",
	"            result = state::transform_point(\n",
	"                state::coordinate_internal,\n",
	"                state::coordinate_object,\n",
	"                displacement * scale);\n",
	"            break;\n",
	"\n",
	"        case displacement_vector_world_space:\n",
	"            result = state::transform_point(\n",
	"                state::coordinate_internal,\n",
	"                state::coordinate_world,\n",
	"                displacement * scale);\n",
	"            break;\n",
	"\n",
	"        default:\n",
	"            result = state::position();\n",
	"            break;\n",
	"    }\n",
	"\n",
	"    return result;\n",
	"}\n",
	"\n",
	"\n",
	"export enum emission_mode\n",
	"[[ \n",
	"    anno::description(\"Emission Mode\")\n",
	"]]\n",
	"{\n",
	"    emission_lx = 0 [[ \n",
	"        anno::display_name(\"Lux - lx (lm/m2)\") \n",
	"    ]],\n",
	"\n",
	"    emission_nt = 1 [[ \n",
	"        anno::display_name(\"Nit - nt (cd/m2)\") \n",
	"    ]]\n",
	"};\n",
};

const char* file_OmniSurfaceLiteBase[] = {
	"/***************************************************************************************************\n",
	" * Copyright 2020 NVIDIA Corporation. All rights reserved.\n",
	" *\n",
	" * Redistribution and use in source and binary forms, with or without\n",
	" * modification, are permitted provided that the following conditions\n",
	" * are met:\n",
	" *  * Redistributions of source code must retain the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer.\n",
	" *  * Redistributions in binary form must reproduce the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer in the\n",
	" *    documentation and/or other materials provided with the distribution.\n",
	" *  * Neither the name of NVIDIA CORPORATION nor the names of its\n",
	" *    contributors may be used to endorse or promote products derived\n",
	" *    from this software without specific prior written permission.\n",
	" *\n",
	" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n",
	" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n",
	" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n",
	" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n",
	" * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n",
	" * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n",
	" * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n",
	" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n",
	" * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n",
	" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n",
	" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
	" **************************************************************************************************/\n",
	"\n",
	"// An implementation of Omni's surface lite\n",
	"\n",
	"mdl 1.6;\n",
	"\n",
	"import ::anno::*;\n",
	"import ::base::*;\n",
	"import ::df::*;\n",
	"import ::limits::*;\n",
	"import ::math::*;\n",
	"import ::state::*;\n",
	"import ::tex::*;\n",
	"\n",
	"import OmniShared::*;\n",
	"\n",
	"export material OmniSurfaceLiteBase(\n",
	"\n",
	"    //Diffuse reflection\n",
	"    //\n",
	"    float diffuse_reflection_weight = float(0.8) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"    \n",
	"    color diffuse_reflection_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"    \n",
	"    float diffuse_reflection_roughness = float(0.0) [[ \n",
	"        anno::display_name(\"Diffuse Roughness\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    //Metalness\n",
	"    //\n",
	"    float metalness = float(0.0) [[ \n",
	"        anno::display_name(\"Metalness\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    //Specular reflection\n",
	"    //\n",
	"    float specular_reflection_weight = float(1.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    color specular_reflection_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_roughness = float(0.2) [[ \n",
	"        anno::display_name(\"Roughness\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::ior_presets specular_reflection_ior_preset = \n",
	"        OmniShared::ior_custom [[\n",
	"        anno::display_name(\"IOR Preset\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"    \n",
	"    uniform float specular_reflection_ior = float(1.5) [[ \n",
	"        anno::display_name(\"IOR\"),    \n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::soft_range(1.0f, 5.0f),\n",
	"        anno::hard_range(0.0f, limits::FLOAT_MAX)\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_anisotropy = float(0.0) [[ \n",
	"        anno::display_name(\"Anisotropy\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_anisotropy_rotation = float(0.0) [[ \n",
	"        anno::display_name(\"Rotation (rad)\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    //Coat\n",
	"    //\n",
	"    float coat_weight = float(0.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    color coat_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    float coat_roughness = float(0.1) [[ \n",
	"        anno::display_name(\"Roughness\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::ior_presets coat_ior_preset = \n",
	"        OmniShared::ior_custom [[\n",
	"        anno::display_name(\"IOR Preset\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform float coat_ior = float(1.5) [[ \n",
	"        anno::display_name(\"IOR\"),    \n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::soft_range(1.0f, 5.0f),\n",
	"        anno::hard_range(1.0f, limits::FLOAT_MAX)\n",
	"    ]],\n",
	"\n",
	"    float coat_anisotropy = float(0.0) [[ \n",
	"        anno::display_name(\"Anisotropy\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float coat_anisotropy_rotation = float(0.0) [[ \n",
	"        anno::display_name(\"Rotation (rad)\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float coat_affect_color = float(0.0) [[\n",
	"        anno::display_name(\"Affect Color\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float coat_affect_roughness = float(0.0) [[\n",
	"        anno::display_name(\"Affect Roughness\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float3 coat_normal = state::normal()\n",
	"    [[\n",
	"        anno::display_name(\"Normal\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    //Emission\n",
	"    //\n",
	"    float emission_weight = float(0.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Emission\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::emission_mode emission_mode = OmniShared::emission_lx\n",
	"    [[\n",
	"        anno::display_name(\"Emission Mode\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"    \n",
	"    float emission_intensity = float(1.0) [[\n",
	"        anno::display_name(\"Intensity\"),\n",
	"        anno::in_group(\"Emission\"),\n",
	"        anno::soft_range(0.0f, 1000.0f)\n",
	"    ]],\n",
	"\n",
	"    color emission_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool emission_use_temperature = false [[ \n",
	"        anno::display_name(\"Use temperature\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    float emission_temperature = float(6500.0) [[\n",
	"        anno::display_name(\"Temperature\"),\n",
	"        anno::in_group(\"Emission\"),\n",
	"        anno::soft_range(0.0f, 10000.0f)\n",
	"    ]],\n",
	"\n",
	"     //Geometry\n",
	"     //\n",
	"    uniform bool enable_opacity = true\n",
	"    [[\n",
	"    	anno::display_name(\"Enable Opacity\"),\n",
	"    	anno::description(\"Enables the use of cutout opacity\"),\n",
	"    	anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    float geometry_opacity = float(1.0) [[\n",
	"        anno::display_name(\"Opacity\"),\n",
	"        anno::in_group(\"Geometry\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float3 geometry_normal = state::normal() [[\n",
	"        anno::display_name(\"Geometry Normal\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    float3 geometry_displacement = float3(0.0) [[\n",
	"        anno::display_name(\"Displacement\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool thin_walled = false\n",
	"    [[\n",
	"	    anno::display_name(\"Thin-walled Material\"),\n",
	"	    anno::description(\"Thin-walled materials do not enclose \"\n",
	"	    	 	      \"volumes and do not feature volumetric effects. \"\n",
	"			      \"Emission is also supported on the backside of \"\n",
	"			      \"thin-walled materials and otherwise not.\")\n",
	"    ]]\n",
	")\n",
	"[[  \n",
	"    anno::display_name(\"OmniSurfaceLiteBase\"),\n",
	"    anno::description(\"A base material for modeling a variety of surfaces.\"),\n",
	"    anno::author(\"NVIDIA Corporation\"),\n",
	"    anno::key_words(string[](\"generic\", \"surface\")),\n",
	"    anno::version(1, 0, 0, \"\"),\n",
	"    anno::modified(2020, 11, 06, \"\")\n",
	"    \n",
	"]] = let {\n",
	"\n",
	"    //Global constants\n",
	"    float anisotropy_rotation_offset = -1.303f;\n",
	"\n",
	"    //Coat - Dielectric microfacet BRDF\n",
	"    float coat_roughness_2 = coat_roughness * coat_roughness;\n",
	"    float2 coat_roughness_anisotropy = \n",
	"        coat_anisotropy != 0.0f ?\n",
	"            OmniShared::compute_anisotropy(coat_roughness_2, coat_anisotropy):\n",
	"            float2(coat_roughness_2);\n",
	"\n",
	"    float coat_roughness_u = coat_roughness_anisotropy.x; \n",
	"    float coat_roughness_v = coat_roughness_anisotropy.y; \n",
	"    float3 coat_tangent_u = \n",
	"        coat_roughness_anisotropy != 0.0f ? \n",
	"            coat_anisotropy_rotation != 0.0f ?\n",
	"                OmniShared::rotate_tangent(\n",
	"                    state::texture_tangent_u(0), \n",
	"                    coat_anisotropy_rotation +  anisotropy_rotation_offset):\n",
	"                state::texture_tangent_u(0): \n",
	"            state::texture_tangent_u(0);\n",
	"\n",
	"    float coat_ior_value = OmniShared::ior_preset_to_value(\n",
	"        coat_ior_preset, \n",
	"        coat_ior);\n",
	"\n",
	"    OmniShared::fresnel_reflectivity coat_fresnel_reflectivity = \n",
	"        OmniShared::approximate_fresnel(\n",
	"            coat_ior_value, \n",
	"            coat_roughness_2);\n",
	"\n",
	"    bsdf coat_brdf = df::microfacet_ggx_smith_bsdf(\n",
	"        roughness_u: coat_roughness_u,\n",
	"        roughness_v: coat_roughness_v,\n",
	"        tint: color(1.0),\n",
	"        multiscatter_tint: color(1.0),\n",
	"        tangent_u: coat_tangent_u,\n",
	"        mode: df::scatter_reflect);\n",
	"\n",
	"    //Specular reflection - Dielectric microfacet BRDF\n",
	"    float specular_reflection_roughness_2 = \n",
	"        specular_reflection_roughness * specular_reflection_roughness;\n",
	"\n",
	"    float coat_affect_roughness_coefficient = \n",
	"        (coat_weight * coat_roughness_2 * coat_affect_roughness);\n",
	"\n",
	"    float specular_reflection_roughness_coefficient = \n",
	"        math::lerp(specular_reflection_roughness_2, 1.0f, coat_affect_roughness_coefficient);\n",
	"\n",
	"    float2 specular_reflection_roughness_anisotropy = \n",
	"        specular_reflection_anisotropy != 0.0f ?\n",
	"            OmniShared::compute_anisotropy(\n",
	"                specular_reflection_roughness_coefficient, \n",
	"                specular_reflection_anisotropy):\n",
	"            float2(specular_reflection_roughness_coefficient);\n",
	"\n",
	"    float specular_reflection_roughness_u = specular_reflection_roughness_anisotropy.x; \n",
	"    float specular_reflection_roughness_v = specular_reflection_roughness_anisotropy.y; \n",
	"\n",
	"    float3 specular_reflection_tangent_u = \n",
	"        specular_reflection_roughness_anisotropy != 0.0f ? \n",
	"            specular_reflection_anisotropy_rotation != 0.0f ?\n",
	"                OmniShared::rotate_tangent(\n",
	"                    state::texture_tangent_u(0),\n",
	"                    specular_reflection_anisotropy_rotation + anisotropy_rotation_offset):\n",
	"                state::texture_tangent_u(0): \n",
	"            state::texture_tangent_u(0);\n",
	"\n",
	"    float specular_reflection_ior_value = OmniShared::ior_preset_to_value(\n",
	"        specular_reflection_ior_preset, \n",
	"        specular_reflection_ior);\n",
	"\n",
	"    OmniShared::fresnel_reflectivity specular_reflection_fresnel_reflectivity = \n",
	"        OmniShared::approximate_fresnel(\n",
	"            specular_reflection_ior_value, \n",
	"            specular_reflection_roughness_2);\n",
	"\n",
	"    bsdf specular_reflection_brdf = df::microfacet_ggx_smith_bsdf(\n",
	"        roughness_u: specular_reflection_roughness_u,\n",
	"        roughness_v: specular_reflection_roughness_v,\n",
	"        tint: specular_reflection_color,\n",
	"        multiscatter_tint: color(1.0),\n",
	"        tangent_u: specular_reflection_tangent_u,\n",
	"        mode: df::scatter_reflect);\n",
	"\n",
	"    //Metal - Conductor microfacet BRDF\n",
	"    float metal_roughness_u = specular_reflection_roughness_u;\n",
	"    float metal_roughness_v = specular_reflection_roughness_v;\n",
	"    float3 metal_tangent_u  = specular_reflection_tangent_u;\n",
	"\n",
	"    bsdf metal_base_brdf = df::microfacet_ggx_smith_bsdf(\n",
	"        roughness_u: metal_roughness_u,\n",
	"        roughness_v: metal_roughness_v,\n",
	"        tint: color(1.0),\n",
	"        multiscatter_tint: color(0.0),\n",
	"        tangent_u: metal_tangent_u,\n",
	"        mode: df::scatter_reflect);\n",
	"\n",
	"    color metal_base_color = diffuse_reflection_color * diffuse_reflection_weight;\n",
	"    color metal_edge_color = specular_reflection_color * specular_reflection_weight;\n",
	"    OmniShared::metal_complex_ior metal_ior = \n",
	"        OmniShared::compute_artistic_to_conductor_fresnel(\n",
	"            metal_base_color, \n",
	"            metal_edge_color);\n",
	"\n",
	"    bsdf metal_brdf = df::custom_curve_layer(\n",
	"        weight: 1.0f,\n",
	"        normal: state::normal(),\n",
	"        normal_reflectivity: 0.0f,\n",
	"        grazing_reflectivity: 1.0f,\n",
	"        exponent: 3.0f,\n",
	"        base: df::fresnel_factor(\n",
	"            ior: metal_ior.n,\n",
	"            extinction_coefficient: metal_ior.k,\n",
	"            base: metal_base_brdf\n",
	"        ),\n",
	"        layer: metal_base_brdf\n",
	"    );\n",
	"\n",
	"    //Diffuse reflection - Diffuse microfacet BRDF \n",
	"    float coat_gamma = 1.0f + coat_affect_color * math::clamp(coat_weight, 0.0f, 1.0f);\n",
	"    color diffuse_color = \n",
	"        math::pow(diffuse_reflection_color * diffuse_reflection_weight, coat_gamma);\n",
	"\n",
	"    bsdf diffuse_reflection_bsdf = df::diffuse_reflection_bsdf(\n",
	"        tint: diffuse_color,\n",
	"        roughness: diffuse_reflection_roughness);\n",
	"\n",
	"    //Emission - Diffuse emission\n",
	"    uniform float emission_unit_intensity = \n",
	"        (emission_mode == OmniShared::emission_lx) ? \n",
	"            math::PI * 1000.0f: \n",
	"            1.0f;\n",
	"\n",
	"    color emission_coat_affect = math::lerp(color(1.0), coat_color, coat_weight);\n",
	"\n",
	"    color emission_final_color = \n",
	"        emission_use_temperature ? \n",
	"            math::blackbody(emission_temperature): \n",
	"            emission_color;\n",
	"\n",
	"    color emission_final_intensity = \n",
	"        emission_weight * emission_intensity * emission_unit_intensity * \n",
	"        emission_final_color * emission_coat_affect;\n",
	"\n",
	"    material_emission emission = material_emission(\n",
	"        emission: df::diffuse_edf(),\n",
	"        intensity: emission_final_intensity,\n",
	"        mode: intensity_radiant_exitance);\n",
	"\n",
	"    //Layering\n",
	"    //\n",
	"    //Diffuse reflection | Specular reflection\n",
	"    bsdf specular_reflection_brdf_mix = df::custom_curve_layer( \n",
	"        weight: specular_reflection_weight,\n",
	"        normal_reflectivity: specular_reflection_fresnel_reflectivity.nr,\n",
	"        grazing_reflectivity: specular_reflection_fresnel_reflectivity.gr,\n",
	"        base: diffuse_reflection_bsdf,\n",
	"        layer: specular_reflection_brdf,\n",
	"        normal: state::normal()\n",
	"    );\n",
	"\n",
	"    //Specular reflection | Metal\n",
	"    bsdf metal_brdf_mix = df::weighted_layer(\n",
	"        weight: metalness,\n",
	"        normal: state::normal(),\n",
	"        base: specular_reflection_brdf_mix,\n",
	"        layer: metal_brdf\n",
	"    ); \n",
	"\n",
	"    //Metal | Coat\n",
	"    bsdf coat_brdf_mix = df::custom_curve_layer(\n",
	"        normal_reflectivity: coat_fresnel_reflectivity.nr,\n",
	"        grazing_reflectivity: coat_fresnel_reflectivity.gr,\n",
	"        weight: coat_weight,\n",
	"        layer: coat_brdf,\n",
	"        base: df::tint(\n",
	"            tint: math::lerp(color(1.0), coat_color, coat_weight), \n",
	"            base: metal_brdf_mix\n",
	"        ),\n",
	"        normal: coat_normal\n",
	"    );\n",
	"\n",
	"    //Surface\n",
	"    material_surface surface = material_surface(\n",
	"        scattering: coat_brdf_mix,\n",
	"        emission: emission\n",
	"    );\n",
	"\n",
	"    //Back Surface\n",
	"    material_surface back_surface = thin_walled ? surface : material_surface(\n",
	"        scattering: bsdf(), \n",
	"        emission: material_emission(\n",
	"            emission: edf(), \n",
	"            intensity: color(0.0), \n",
	"            mode: intensity_radiant_exitance\n",
	"        )\n",
	"    );\n",
	"\n",
	"    //Volume\n",
	"    material_volume volume = material_volume();\n",
	"\n",
	"    //Geometry\n",
	"    material_geometry geometry = material_geometry(\n",
	"        displacement: geometry_displacement,\n",
	"        cutout_opacity: enable_opacity ? geometry_opacity : 1.0,\n",
	"        normal: geometry_normal\n",
	"    );\n",
	"\n",
	"} in material(\n",
	"    thin_walled: thin_walled,\n",
	"    ior: color(1.0f),\n",
	"    surface: surface,\n",
	"    backface: back_surface,\n",
	"    volume: volume,\n",
	"    geometry: geometry\n",
	");\n",
};

const char* file_OmniSurfaceLiteNN[] = {
	"/***************************************************************************************************\n",
	" * Copyright 2020 NVIDIA Corporation. All rights reserved.\n",
	" *\n",
	" * Redistribution and use in source and binary forms, with or without\n",
	" * modification, are permitted provided that the following conditions\n",
	" * are met:\n",
	" *  * Redistributions of source code must retain the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer.\n",
	" *  * Redistributions in binary form must reproduce the above copyright\n",
	" *    notice, this list of conditions and the following disclaimer in the\n",
	" *    documentation and/or other materials provided with the distribution.\n",
	" *  * Neither the name of NVIDIA CORPORATION nor the names of its\n",
	" *    contributors may be used to endorse or promote products derived\n",
	" *    from this software without specific prior written permission.\n",
	" *\n",
	" * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n",
	" * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n",
	" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n",
	" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n",
	" * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n",
	" * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n",
	" * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n",
	" * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n",
	" * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n",
	" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n",
	" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
	" **************************************************************************************************/\n",
	"\n",
	"// A wrapper for Omni's surface lite using nearest neighbour texture lookups\n",
	"\n",
	"mdl 1.6;\n",
	"\n",
	"import ::anno::*;\n",
	"import ::base::*;\n",
	"import ::limits::*;\n",
	"import ::state::*;\n",
	"import ::tex::*;\n",
	"\n",
	"import OmniSurfaceLiteBase::*;\n",
	"import OmniShared::*;\n",
	"import OmniImageNN::*;\n",
	"\n",
	"export material OmniSurfaceLiteNN(\n",
	"\n",
	"    //Diffuse reflection\n",
	"    //\n",
	"    float diffuse_reflection_weight = float(0.8) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d diffuse_reflection_weight_image = texture_2d() [[ \n",
	"        anno::display_name(\"Weight Image\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode diffuse_reflection_weight_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Weight Image Alpha Mode\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    color diffuse_reflection_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d diffuse_reflection_color_image = texture_2d() [[ \n",
	"        anno::display_name(\"Color Image\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    float diffuse_reflection_roughness = float(0.0) [[ \n",
	"        anno::display_name(\"Diffuse Roughness\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d diffuse_reflection_roughness_image = texture_2d() [[ \n",
	"        anno::display_name(\"Diffuse Roughness Image\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode diffuse_reflection_roughness_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Diffuse Roughness Alpha Mode\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    //Metal\n",
	"    //\n",
	"    float metalness = float(0.0) [[ \n",
	"        anno::display_name(\"Metalness\"),\n",
	"        anno::in_group(\"Base\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d metalness_image = texture_2d() [[ \n",
	"        anno::display_name(\"Metalness Image\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode metalness_image_alpha_mode = OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Metalness Image Alpha Mode\"),\n",
	"        anno::in_group(\"Base\")\n",
	"    ]],\n",
	"\n",
	"    //Specular reflection\n",
	"    //\n",
	"    float specular_reflection_weight = float(1.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d specular_reflection_weight_image = texture_2d() [[ \n",
	"        anno::display_name(\"Weight Image\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode specular_reflection_weight_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Weight Image Alpha Mode\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    color specular_reflection_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d specular_reflection_color_image = texture_2d() [[ \n",
	"        anno::display_name(\"Color Image\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_roughness = float(0.2) [[ \n",
	"        anno::display_name(\"Roughness\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d specular_reflection_roughness_image = texture_2d() [[ \n",
	"        anno::display_name(\"Roughness Image\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode specular_reflection_roughness_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Roughness Image Alpha Mode\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::ior_presets specular_reflection_ior_preset = \n",
	"        OmniShared::ior_custom [[\n",
	"        anno::display_name(\"IOR Preset\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform float specular_reflection_ior = float(1.5) [[ \n",
	"        anno::display_name(\"IOR\"),    \n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::soft_range(1.0f, 5.0f),\n",
	"        anno::hard_range(1.0f, limits::FLOAT_MAX)\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_anisotropy = float(0.0) [[ \n",
	"        anno::display_name(\"Anisotropy\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d specular_reflection_anisotropy_image = texture_2d() [[ \n",
	"        anno::display_name(\"Anisotropy Image\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode specular_reflection_anisotropy_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Anisotropy Image Alpha Mode\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    float specular_reflection_anisotropy_rotation = float(0.0) [[ \n",
	"        anno::display_name(\"Rotation (rad)\"),\n",
	"        anno::in_group(\"Specular\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d specular_reflection_anisotropy_rotation_image = texture_2d() [[ \n",
	"        anno::display_name(\"Anisotropy Rotation Image\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode specular_reflection_anisotropy_rotation_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Anisotropy Rotation Alpha Mode\"),\n",
	"        anno::in_group(\"Specular\")\n",
	"    ]],\n",
	"\n",
	"    //Coat\n",
	"    //\n",
	"    float coat_weight = float(0.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_weight_image = texture_2d() [[ \n",
	"        anno::display_name(\"Weight Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_weight_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Weight Image Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    color coat_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_color_image = texture_2d() [[ \n",
	"        anno::display_name(\"Color Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    float coat_roughness = float(0.1) [[ \n",
	"        anno::display_name(\"Roughness\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_roughness_image = texture_2d() [[ \n",
	"        anno::display_name(\"Roughness Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_roughness_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Roughness Image Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::ior_presets coat_ior_preset = \n",
	"        OmniShared::ior_custom [[\n",
	"        anno::display_name(\"IOR Preset\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform float coat_ior = float(1.5) [[ \n",
	"        anno::display_name(\"IOR\"),    \n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::soft_range(1.0f, 5.0f),\n",
	"        anno::hard_range(1.0f, limits::FLOAT_MAX)\n",
	"    ]],\n",
	"\n",
	"    float coat_anisotropy = float(0.0) [[ \n",
	"        anno::display_name(\"Anisotropy\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_anisotropy_image = texture_2d() [[ \n",
	"        anno::display_name(\"Anisotropy Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_anisotropy_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Anisotropy Image Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    float coat_anisotropy_rotation = float(0.0) [[ \n",
	"        anno::display_name(\"Rotation (rad)\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_anisotropy_rotation_image = texture_2d() [[ \n",
	"        anno::display_name(\"Anisotropy Rotation Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_anisotropy_rotation_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Anisotropy Rotation Image Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    float coat_affect_color = float(0.0) [[\n",
	"        anno::display_name(\"Affect Color\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_affect_color_image = texture_2d() [[ \n",
	"        anno::display_name(\"Affect Color Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_affect_color_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Affect Color Image Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    float coat_affect_roughness = float(0.0) [[\n",
	"        anno::display_name(\"Affect Roughness\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_affect_roughness_image = texture_2d() [[ \n",
	"        anno::display_name(\"Affect Roughness Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode coat_affect_roughness_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Affect Roughness Alpha Mode\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform float coat_normal_strength = float(1.0) [[ \n",
	"        anno::display_name(\"Normal Strength\"),\n",
	"        anno::in_group(\"Coat\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    float3 coat_normal = state::normal()\n",
	"    [[\n",
	"        anno::display_name(\"Normal\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d coat_normal_image = texture_2d() [[ \n",
	"        anno::display_name(\"Normal Map Image\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool coat_normal_image_flip_r_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip R Channel\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool coat_normal_image_flip_g_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip G Channel\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool coat_normal_image_flip_b_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip B Channel\"),\n",
	"        anno::in_group(\"Coat\")\n",
	"    ]],\n",
	"\n",
	"    //Emission\n",
	"    //\n",
	"    float emission_weight = float(0.0) [[ \n",
	"        anno::display_name(\"Weight\"),\n",
	"        anno::in_group(\"Emission\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d emission_weight_image = texture_2d() [[ \n",
	"        anno::display_name(\"Weight Image\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode emission_weight_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Weight Image Alpha Mode\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::emission_mode emission_mode = OmniShared::emission_lx\n",
	"    [[\n",
	"        anno::display_name(\"Emission Mode\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    float emission_intensity = float(1.0) [[\n",
	"        anno::display_name(\"Intensity\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d emission_intensity_image = texture_2d() [[ \n",
	"        anno::display_name(\"Intensity Image\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode emission_intensity_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Intensity Image Alpha Mode\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    color emission_color = color(1.0) [[\n",
	"        anno::display_name(\"Color\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d emission_color_image = texture_2d() [[ \n",
	"        anno::display_name(\"Color Image\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool emission_use_temperature = false [[ \n",
	"        anno::display_name(\"Use temperature\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    float emission_temperature = float(6500.0) [[\n",
	"        anno::display_name(\"Temperature\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d emission_temperature_image = texture_2d() [[ \n",
	"        anno::display_name(\"Temperature Image\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode emission_temperature_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Temperature Image Alpha Mode\"),\n",
	"        anno::in_group(\"Emission\")\n",
	"    ]],\n",
	"\n",
	"    //Geometry\n",
	"    //\n",
	"    uniform bool enable_opacity = true\n",
	"    [[\n",
	"    	anno::display_name(\"Enable Opacity\"),\n",
	"    	anno::description(\"Enables the use of cutout opacity\"),\n",
	"    	anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"	\n",
	"    float geometry_opacity = float(1.0) [[\n",
	"        anno::display_name(\"Opacity\"),\n",
	"        anno::in_group(\"Geometry\"),\n",
	"        anno::hard_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d geometry_opacity_image = texture_2d() [[ \n",
	"        anno::display_name(\"Opacity Image\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode geometry_opacity_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"        anno::display_name(\"Opacity Image Alpha Mode\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform float geometry_normal_strength = float(1.0) [[ \n",
	"        anno::display_name(\"Geometry Normal Strength\"),\n",
	"        anno::in_group(\"Geometry\"),\n",
	"        anno::soft_range(0.0f, 1.0f),\n",
	"        anno::hard_range(0.0f, limits::FLOAT_MAX)\n",
	"    ]],\n",
	"\n",
	"    float3 geometry_normal = state::normal() [[\n",
	"        anno::display_name(\"Geometry Normal\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d geometry_normal_image = texture_2d() [[ \n",
	"        anno::display_name(\"Geometry Normal Map Image\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"// Not implemented\n",
	"//    uniform OmniShared::normal_mode geometry_normal_mode = \n",
	"//        OmniShared::normal_tangent_space [[\n",
	"//            anno::display_name(\"Normal Map Mode\"),\n",
	"//            anno::in_group(\"Geometry\")\n",
	"//    ]],\n",
	"\n",
	"    uniform bool geometry_normal_image_flip_r_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip R Channel\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool geometry_normal_image_flip_g_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip G Channel\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool geometry_normal_image_flip_b_channel = false [[\n",
	"        anno::display_name(\"Normal Map Flip B Channel\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::tangent_bitangent_mapping geometry_tangent_bitangent_mapping = \n",
	"        OmniImageNN::red_green [[\n",
	"        anno::display_name(\"Tangent Bitangent Mapping\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    //Displacement\n",
	"    float3 geometry_displacement = float3(0.0) [[\n",
	"        anno::display_name(\"Displacement\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniShared::displacement_mode geometry_displacement_mode = \n",
	"        OmniShared::displacement_height [[\n",
	"            anno::display_name(\"Displacement Mode\"),\n",
	"            anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d geometry_displacement_image = texture_2d() [[ \n",
	"        anno::display_name(\"Displacement Image\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode geometry_displacement_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"            anno::display_name(\"Displacement Image Alpha Mode\"),\n",
	"            anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    float geometry_displacement_scale = float(1.0) [[\n",
	"        anno::display_name(\"Displacement Scale\"),\n",
	"        anno::in_group(\"Geometry\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    uniform texture_2d geometry_displacement_scale_image = texture_2d() [[ \n",
	"        anno::display_name(\"Displacement Scale Image\"),\n",
	"        anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::alpha_mode geometry_displacement_scale_image_alpha_mode = \n",
	"        OmniImageNN::alpha_default [[\n",
	"            anno::display_name(\"Displacement Scale Image Alpha Mode\"),\n",
	"            anno::in_group(\"Geometry\")\n",
	"    ]],\n",
	"\n",
	"    float geometry_displacement_scalar_zero_value = float(0.0) [[\n",
	"        anno::display_name(\"Displacement Scalar Zero Value\"),\n",
	"        anno::in_group(\"Geometry\"),\n",
	"        anno::soft_range(0.0f, 1.0f)\n",
	"    ]],\n",
	"\n",
	"    //UVW\n",
	"    //\n",
	"    uniform base::texture_coordinate_system uvw_texture_coordinate_system = \n",
	"        base::texture_coordinate_uvw [[\n",
	"            anno::display_name(\"Texture Coordinate\"),\n",
	"            anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform int uvw_uv_set = 0 [[\n",
	"        anno::display_name(\"UV Set\"),\n",
	"        anno::in_group(\"UVW Coordinates\"),\n",
	"        anno::hard_range(0, 4)\n",
	"    ]],\n",
	"\n",
	"    uniform bool uvw_ignore_missing_textures = false [[\n",
	"        anno::display_name(\"Ignore Missing Images\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    color uvw_missing_texture_color = color(0.0, 0.0, 0.0) [[\n",
	"        anno::display_name(\"Missing Image Color\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool uvw_use_uv_coords = false [[\n",
	"        anno::display_name(\"Use UV Coords\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    float2 uvw_uv_coords = float2(0.0) [[\n",
	"        anno::display_name(\"UV Coords\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float uvw_s_offset = 0.0f [[\n",
	"        anno::display_name(\"Offset U\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float uvw_t_offset = 0.0f [[\n",
	"        anno::display_name(\"Offset V\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform OmniImageNN::wrap_mode uvw_s_wrap = OmniImageNN::wrap_periodic [[\n",
	"        anno::display_name(\"Wrap U\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"    \n",
	"    uniform OmniImageNN::wrap_mode uvw_t_wrap = OmniImageNN::wrap_periodic [[\n",
	"        anno::display_name(\"Wrap V\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"    \n",
	"    uniform float uvw_s_scale = 1.0f [[\n",
	"        anno::display_name(\"Scale U\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float uvw_t_scale = 1.0f [[\n",
	"        anno::display_name(\"Scale V\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool uvw_s_flip = false [[\n",
	"        anno::display_name(\"Flip U\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool uvw_t_flip = false [[\n",
	"        anno::display_name(\"Flip V\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool uvw_swap_st = false [[\n",
	"        anno::display_name(\"Swap UV\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    //Projection Coordinates (Local / World)\n",
	"    uniform base::projection_mode uvw_projection_mode = base::projection_cubic [[\n",
	"        anno::display_name(\"Projection Mode\"),\n",
	"        anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float3 uvw_projection_translate =  float3(0.0f)\n",
	"    [[\n",
	"	    anno::display_name(\"Translate\"),\n",
	"	    anno::description(\"Translate the projected texture.\"),\n",
	"	    anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float3 uvw_projection_rotate =  float3(0.0f)\n",
	"    [[\n",
	"	    anno::display_name(\"Rotate\"),\n",
	"	    anno::description(\"Rotate the projected texture.\"),\n",
	"	    anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform float3 uvw_projection_scale =  float3(1.0f)\n",
	"    [[\n",
	"	    anno::display_name(\"Scale\"),\n",
	"	    anno::description(\"Scale the projected texture.\"),\n",
	"	    anno::in_group(\"UVW Coordinates\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool thin_walled = false\n",
	"    [[\n",
	"	    anno::display_name(\"Thin-walled Material\"),\n",
	"	    anno::description(\"Thin-walled materials do not enclose \"\n",
	"	    	 	      \"volumes and do not feature volumetric effects. \"\n",
	"			      \"Emission is also supported on the backside of \"\n",
	"			      \"thin-walled materials and otherwise not.\")\n",
	"    ]],\n",
	"\n",
	"    uniform bool filtered_textures = false\n",
	"    [[\n",
	"	    anno::display_name(\"Filtered Textures\"),\n",
	"	    anno::description(\"Filtered texture lookup for a smoother material look instead of the blocky texel look.\")\n",
	"    ]]\n",
	"\n",
	") \n",
	"[[\n",
	"    anno::display_name(\"OmniSurfaceLite\"),\n",
	"    anno::description(\"A base material for modeling a variety of surfaces.\"),\n",
	"    anno::author(\"NVIDIA Corporation\"),\n",
	"    anno::key_words(string[](\"generic\", \"surface\")),\n",
	"    anno::version(1, 0, 0, \"\"),\n",
	"    anno::modified(2020, 9, 21, \"\")\n",
	"\n",
	"]] = let {\n",
	"    \n",
	"    base::texture_coordinate_info texture_coordinate_info = OmniImageNN::compute_texture_coordinate(\n",
	"        uvw_texture_coordinate_system,\n",
	"        uvw_uv_set,\n",
	"        uvw_s_offset,\n",
	"        uvw_t_offset,\n",
	"        uvw_s_scale,\n",
	"        uvw_t_scale,\n",
	"        uvw_s_flip,\n",
	"        uvw_t_flip,\n",
	"        uvw_swap_st,\n",
	"        uvw_projection_mode,\n",
	"        uvw_projection_translate,\n",
	"        uvw_projection_rotate,\n",
	"        uvw_projection_scale);\n",
	"\n",
	"    material base = OmniSurfaceLiteBase::OmniSurfaceLiteBase (\n",
	"\n",
	"    //Base\n",
	"    //\n",
	"    diffuse_reflection_weight: tex::texture_isvalid(diffuse_reflection_weight_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                diffuse_reflection_weight_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"		texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            diffuse_reflection_weight, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            diffuse_reflection_weight_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        diffuse_reflection_weight,\n",
	"\n",
	"    diffuse_reflection_color: tex::texture_isvalid(diffuse_reflection_color_image) ? \n",
	"        OmniImageNN::texture_lookup_2(\n",
	"            diffuse_reflection_color_image,\n",
	"            uvw_ignore_missing_textures,\n",
	"            uvw_missing_texture_color,\n",
	"            uvw_use_uv_coords,\n",
	"            uvw_uv_coords,\n",
	"            uvw_s_wrap,\n",
	"            uvw_t_wrap,\n",
	"	    filtered_textures,\n",
	"            texture_coordinate_info\n",
	"        ).tint :\n",
	"        diffuse_reflection_color,\n",
	"\n",
	"    diffuse_reflection_roughness: tex::texture_isvalid(diffuse_reflection_roughness_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                diffuse_reflection_roughness_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            diffuse_reflection_roughness, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            diffuse_reflection_roughness_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        diffuse_reflection_roughness,\n",
	"\n",
	"    //Metalness\n",
	"    //\n",
	"    metalness: tex::texture_isvalid(metalness_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                metalness_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            metalness, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            metalness_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        metalness,\n",
	" \n",
	"    //Specular reflection\n",
	"    //\n",
	"    specular_reflection_weight: tex::texture_isvalid(specular_reflection_weight_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                specular_reflection_weight_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            specular_reflection_weight, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            specular_reflection_weight_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        specular_reflection_weight,\n",
	"\n",
	"    specular_reflection_color: tex::texture_isvalid(specular_reflection_color_image) ?\n",
	"        OmniImageNN::texture_lookup_2(\n",
	"            specular_reflection_color_image,\n",
	"            uvw_ignore_missing_textures,\n",
	"            uvw_missing_texture_color,\n",
	"            uvw_use_uv_coords,\n",
	"            uvw_uv_coords,\n",
	"            uvw_s_wrap,\n",
	"            uvw_t_wrap,\n",
	"	    filtered_textures,\n",
	"            texture_coordinate_info\n",
	"        ).tint :\n",
	"        specular_reflection_color,\n",
	"\n",
	"    specular_reflection_roughness: tex::texture_isvalid(specular_reflection_roughness_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                specular_reflection_roughness_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            specular_reflection_roughness, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            specular_reflection_roughness_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        specular_reflection_roughness,\n",
	"\n",
	"    specular_reflection_ior_preset: specular_reflection_ior_preset,\n",
	"    specular_reflection_ior: specular_reflection_ior,\n",
	"\n",
	"    specular_reflection_anisotropy: tex::texture_isvalid(specular_reflection_anisotropy_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                specular_reflection_anisotropy_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            specular_reflection_anisotropy, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            specular_reflection_anisotropy_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        specular_reflection_anisotropy,\n",
	"\n",
	"    specular_reflection_anisotropy_rotation: tex::texture_isvalid(\n",
	"            specular_reflection_anisotropy_rotation_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                specular_reflection_anisotropy_rotation_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            specular_reflection_anisotropy_rotation, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            specular_reflection_anisotropy_rotation_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        specular_reflection_anisotropy_rotation,\n",
	"\n",
	"    //Coat\n",
	"    //\n",
	"    coat_weight: tex::texture_isvalid(coat_weight_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_weight_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_weight, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_weight_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_weight,\n",
	"\n",
	"    coat_color: tex::texture_isvalid(coat_color_image) ?\n",
	"        OmniImageNN::texture_lookup_2(\n",
	"            coat_color_image,\n",
	"            uvw_ignore_missing_textures,\n",
	"            uvw_missing_texture_color,\n",
	"            uvw_use_uv_coords,\n",
	"            uvw_uv_coords,\n",
	"            uvw_s_wrap,\n",
	"            uvw_t_wrap,\n",
	"	    filtered_textures,\n",
	"            texture_coordinate_info\n",
	"        ).tint :\n",
	"        coat_color,\n",
	"\n",
	"    coat_roughness: tex::texture_isvalid(coat_roughness_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_roughness_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_roughness, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_roughness_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_roughness,\n",
	"\n",
	"    coat_ior_preset: coat_ior_preset,\n",
	"    coat_ior: coat_ior,\n",
	"\n",
	"    coat_anisotropy: tex::texture_isvalid(coat_anisotropy_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_anisotropy_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_anisotropy, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_anisotropy_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_anisotropy,\n",
	"\n",
	"    coat_anisotropy_rotation: tex::texture_isvalid(coat_anisotropy_rotation_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_anisotropy_rotation_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_anisotropy_rotation, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_anisotropy_rotation_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_anisotropy_rotation,\n",
	"\n",
	"    coat_affect_color: tex::texture_isvalid(coat_affect_color_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_affect_color_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_affect_color, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_affect_color_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_affect_color,\n",
	"\n",
	"    coat_affect_roughness: tex::texture_isvalid(coat_affect_roughness_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                coat_affect_roughness_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            coat_affect_roughness, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            coat_affect_roughness_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        coat_affect_roughness,\n",
	"\n",
	"    coat_normal: tex::texture_isvalid(coat_normal_image) ?\n",
	"        OmniImageNN::normal_mapping(\n",
	"            OmniImageNN::normal_lookup_2(\n",
	"                coat_normal_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"                uvw_s_flip,\n",
	"                uvw_t_flip,\n",
	"                coat_normal_strength,\n",
	"                coat_normal_image_flip_r_channel,\n",
	"                coat_normal_image_flip_g_channel,\n",
	"                coat_normal_image_flip_b_channel,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ).normal,\n",
	"            geometry_tangent_bitangent_mapping,\n",
	"            coat_normal\n",
	"        ):\n",
	"        coat_normal,\n",
	"\n",
	"    //Emission\n",
	"    //\n",
	"    emission_weight: tex::texture_isvalid(emission_weight_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                emission_weight_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            emission_weight, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            emission_weight_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        emission_weight,\n",
	"\n",
	"    emission_mode: emission_mode,\n",
	"\n",
	"    emission_intensity: tex::texture_isvalid(emission_intensity_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                emission_intensity_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            emission_intensity, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            emission_intensity_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        emission_intensity,\n",
	"\n",
	"    emission_color: tex::texture_isvalid(emission_color_image) ?\n",
	"        OmniImageNN::texture_lookup_2(\n",
	"            emission_color_image,\n",
	"            uvw_ignore_missing_textures,\n",
	"            uvw_missing_texture_color,\n",
	"            uvw_use_uv_coords,\n",
	"            uvw_uv_coords,\n",
	"            uvw_s_wrap,\n",
	"            uvw_t_wrap,\n",
	"	    filtered_textures,\n",
	"	    texture_coordinate_info\n",
	"        ).tint :\n",
	"       emission_color,\n",
	"\n",
	"    emission_use_temperature: emission_use_temperature,\n",
	"\n",
	"    emission_temperature: tex::texture_isvalid(emission_temperature_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                emission_temperature_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            emission_temperature, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            emission_temperature_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        emission_temperature,\n",
	"\n",
	"    //Geometry\n",
	"    //\n",
	"	enable_opacity: enable_opacity,\n",
	"	\n",
	"    geometry_opacity: tex::texture_isvalid(geometry_opacity_image) ?\n",
	"        OmniImageNN::texture_adjustment(\n",
	"            OmniImageNN::texture_lookup_2(\n",
	"                geometry_opacity_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ),\n",
	"            0.0f,       //exposure\n",
	"            color(0.5), //default_color\n",
	"            color(1.0), //color_gain\n",
	"            color(0.0), //color_offset\n",
	"            geometry_opacity, //alpha_gain\n",
	"            0.0f,       //alpha_offset\n",
	"            geometry_opacity_image_alpha_mode,\n",
	"            false,      //invert\n",
	"            0.0f        //blend_factor\n",
	"        ).mono :\n",
	"        geometry_opacity,\n",
	"\n",
	"    geometry_normal: tex::texture_isvalid(geometry_normal_image) ?\n",
	"        OmniImageNN::normal_mapping(\n",
	"            OmniImageNN::normal_lookup_2(\n",
	"                geometry_normal_image,\n",
	"                uvw_ignore_missing_textures,\n",
	"                uvw_missing_texture_color,\n",
	"                uvw_use_uv_coords,\n",
	"                uvw_uv_coords,\n",
	"                uvw_s_wrap,\n",
	"                uvw_t_wrap,\n",
	"                uvw_s_flip,\n",
	"                uvw_t_flip,\n",
	"                geometry_normal_strength,\n",
	"                geometry_normal_image_flip_r_channel,\n",
	"                geometry_normal_image_flip_g_channel,\n",
	"                geometry_normal_image_flip_b_channel,\n",
	"		filtered_textures,\n",
	"                texture_coordinate_info\n",
	"            ).normal,\n",
	"            geometry_tangent_bitangent_mapping,\n",
	"            geometry_normal\n",
	"        ):\n",
	"        geometry_normal,\n",
	"        \n",
	"    geometry_displacement: tex::texture_isvalid(geometry_displacement_image) ?\n",
	"        OmniShared::displacement_adjustment(\n",
	"            (geometry_displacement_mode == OmniShared::displacement_height) ?\n",
	"                float3(OmniImageNN::texture_adjustment(\n",
	"                    OmniImageNN::texture_lookup_2(\n",
	"                        geometry_displacement_image,\n",
	"                        uvw_ignore_missing_textures,\n",
	"                        uvw_missing_texture_color,\n",
	"                        uvw_use_uv_coords,\n",
	"                        uvw_uv_coords,\n",
	"                        uvw_s_wrap,\n",
	"                        uvw_t_wrap,\n",
	"			filtered_textures,\n",
	"                        texture_coordinate_info\n",
	"                    ),\n",
	"                    0.0f,       //exposure\n",
	"                    color(0.5), //default_color\n",
	"                    color(1.0), //color_gain\n",
	"                    color(0.0), //color_offset\n",
	"                    1.0f,       //alpha_gain\n",
	"                    -1.0f * geometry_displacement_scalar_zero_value, //alpha_offset\n",
	"                    geometry_displacement_image_alpha_mode,\n",
	"                    false,      //invert\n",
	"                    0.0f        //blend_factor\n",
	"                ).mono) :\n",
	"\n",
	"                float3(OmniImageNN::texture_lookup_2(\n",
	"                        geometry_displacement_image,\n",
	"                        uvw_ignore_missing_textures,\n",
	"                        uvw_missing_texture_color,\n",
	"                        uvw_use_uv_coords,\n",
	"                        uvw_uv_coords,\n",
	"                        uvw_s_wrap,\n",
	"                        uvw_t_wrap,\n",
	"			filtered_textures,\n",
	"                        texture_coordinate_info\n",
	"                    ).tint\n",
	"                ),\n",
	"\n",
	"            geometry_displacement_mode,\n",
	"\n",
	"            tex::texture_isvalid(geometry_displacement_scale_image) ?\n",
	"                OmniImageNN::texture_adjustment(\n",
	"                    OmniImageNN::texture_lookup_2(\n",
	"                        geometry_displacement_scale_image,\n",
	"                        uvw_ignore_missing_textures,\n",
	"                        uvw_missing_texture_color,\n",
	"                        uvw_use_uv_coords,\n",
	"                        uvw_uv_coords,\n",
	"                        uvw_s_wrap,\n",
	"                        uvw_t_wrap,\n",
	"			filtered_textures,\n",
	"                        texture_coordinate_info\n",
	"                    ),\n",
	"                    0.0f,       //exposure\n",
	"                    color(0.5), //default_color\n",
	"                    color(1.0), //color_gain\n",
	"                    color(0.0), //color_offset\n",
	"                    geometry_displacement_scale, //alpha_gain\n",
	"                    0.0f,       //alpha_offset\n",
	"                    geometry_displacement_scale_image_alpha_mode,\n",
	"                    false,      //invert\n",
	"                    0.0f        //blend_factor\n",
	"                ).mono :\n",
	"                geometry_displacement_scale\n",
	"        ):\n",
	"        geometry_displacement,\n",
	"    thin_walled: thin_walled\n",
	"    );\n",
	"    \n",
	"} in material(\n",
	"    thin_walled: thin_walled,\n",
	"    ior: base.ior,\n",
	"    surface: base.surface,\n",
	"    backface: base.backface,\n",
	"    volume: base.volume,\n",
	"    geometry: base.geometry\n",
	");\n",
};

const int mdlFileLines[] = {
	113,
	557,
	542,
	473,
	1330,
};

const char** mdlFileContents[] = {
	file_Mineways,
	file_OmniImageNN,
	file_OmniShared,
	file_OmniSurfaceLiteBase,
	file_OmniSurfaceLiteNN,
	NULL
};

const wchar_t* mdlFileNames[] = {
	L"Mineways.mdl",
	L"OmniImageNN.mdl",
	L"OmniShared.mdl",
	L"OmniSurfaceLiteBase.mdl",
	L"OmniSurfaceLiteNN.mdl",
};
